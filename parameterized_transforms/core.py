"""
Copyright 2025 Apple Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""


import typing as t
import torch

from abc import abstractmethod
from abc import ABC
from enum import Enum
from functools import reduce
from PIL import Image


class TransformMode(Enum):
    """Defines the enum for the mode of the transform. Currently, the
    transforms can either have `CASCADE` or `COMPOSE` mode.
    """

    CASCADE = "CASCADE"
    CONSUME = "CONSUME"


class DefaultParamsMode(Enum):
    """Defines the enum for the default parameters mode for certain
    transforms. In these transforms, there are multiple parameter settings
    that can lead to the result of returning the same image.

    For instance, in `ColorJitter` transform, we can get the default
    parameters for perturbing brightness, contrast, saturation, and hue, and
    apply these perturbations in ANY order to retain the same image.

    In such cases, we might want to have stochasticity during training and a
    fixed behavior during testing. This enum can help in such cases.
    """

    UNIQUE = "UNIQUE"
    RANDOMIZED = "RANDOMIZED"


IMAGE_TYPE = t.Union[torch.Tensor, Image.Image]
SCALAR_TYPE = t.Union[int, float]
PARAM_TYPE = t.Tuple[SCALAR_TYPE, ...]
TRANSFORM_RETURN_TYPE = t.Tuple[IMAGE_TYPE, PARAM_TYPE]
TRANSFORM_MODE_TYPE = t.Union[str, TransformMode]


# --------------------------------------------------------------------------------
# Core base transform.
# --------------------------------------------------------------------------------


class Transform(ABC):
    """Defines the core base for all transforms."""

    def __init__(
        self, *args, tx_mode: TRANSFORM_MODE_TYPE = TransformMode.CASCADE, **kwargs
    ) -> None:
        """The initializer.

        :param tx_mode: The mode of the transform as a keyword only argument.
            DEFAULT: `TransformMode.CASCADE`.
        :param args: The arguments for the underlying transform.
        :param kwargs: The keyword arguments for the underlying transform.
        """
        super(Transform, self).__init__(*args, **kwargs)

        self.tx_mode = Transform.data_to_tx_mode(tx_mode=tx_mode)

    @staticmethod
    def data_to_tx_mode(tx_mode: TRANSFORM_MODE_TYPE) -> TransformMode:
        """Convert the given transform mode data into its `enum`.
        `
                :param tx_mode: The input mode of the transform.

                :returns: The cleaned mode.

                If the mode is NOT found, we raise a not-implemented error.
        """
        if isinstance(tx_mode, TransformMode):
            return tx_mode

        try:
            return TransformMode[tx_mode]
        except KeyError as e:
            raise e.__class__(
                f"ERROR | Transform mode: {tx_mode} is NOT implemented, "
                "ensure that the transform mode is "
                "`ptc.TransformMode` instance or "
                f"a string from: 'CASCADE', 'CONSUME'; hit error\n{e}"
            )

    @staticmethod
    def concat_params(*params) -> PARAM_TYPE:
        """Concatenates a given tuple of parameters into one.

        :param params: The tuple of parameters, each of which is a `tuple`.

        :returns: The concatenated parameters as the answer.
        """
        return reduce((lambda param_1, param_2: param_1 + param_2), params, ())

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """
        raise NotImplementedError(
            "ERROR | `set_param_count` is the recommended method to set the "
            "`param_count` attribute on transform classes and "
            "MUST be implemented by the subclass."
        )

    def __call__(
        self, img: IMAGE_TYPE, params: PARAM_TYPE = ()
    ) -> TRANSFORM_RETURN_TYPE:
        """Implements the forward pass with dunder call.

        :param img: The data point to be augmented.
        :param params: The parameters for the augmentations so far.
            DEFAULT: `()`, the empty tuple.

        :returns: The augmentation and appropriately updated parameterization.
        """

        return (
            self.cascade_transform(img=img, params=params)
            if self.tx_mode == TransformMode.CASCADE
            else self.consume_transform(img=img, params=params)
        )

    @abstractmethod
    def cascade_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Inputs the data point and previous parameters, generates the
        parameters for the current transform, augments previous parameters
        with current parameters, and returns the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The parameters for the augmentations so far.

        :returns: The tuple of augmented data point and the params.

        This method consists of 5 steps--
        1. Generate local raw parameters for the transform.
        2. Generate augmentation from the data point and local raw parameters.
        3. Post-process the local raw parameters to get processed parameters.
        4. Attach processed parameters to those input to this method.
        5. Return augmented data point and combined processed parameters.
        """

    @abstractmethod
    def consume_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        This method consists of 4 steps--
        1. Detach processed parameters from the input parameters.
        2. Pre-process the processed parameters to get local raw parameters.
        3. Generate augmentation from the data point and local raw parameters.
        4. Return augmented data point along with remaining parameters.
        """

    @abstractmethod
    def get_default_params(self, img: IMAGE_TYPE, processed: bool = True) -> PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

    @property
    def name(self) -> str:
        """Returns the name of the transform.

        :returns: The name of the transform.
        """

        return self.__class__.__name__

    def __repr__(self) -> str:
        """Defines the representation of the transform.

        :returns: The representation of the transform.
        """
        return self.__str__()

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return f"{self.name}()"


class AtomicTransform(Transform):
    """Defines the base for an atomic transform."""

    def __init__(self, *args, **kwargs) -> None:
        """The initializer.

        :param tx_mode: The mode of the transform.
            DEFAULT: `TransformMode.CASCADE`.
        :param args: The arguments for the underlying transform.
        :param kwargs: The keyword arguments for the underlying transform.
        """
        super(AtomicTransform, self).__init__(*args, **kwargs)

    def cascade_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Input the data point and previous parameters, generate the parameters
        for the current transform, augment previous parameters with current
        parameters, and return the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The parameters for the augmentations so far.

        :returns: The tuple of augmented data point and the params.

        This method consists of 5 steps--
        1. Generate local raw parameters for the transform.
        2. Generate augmentation from the data point and local raw parameters.
        3. Post-process the local raw parameters to get processed parameters.
        4. Attach processed parameters to those input to this method.
        5. Return augmented data point and combined processed parameters.
        """
        local_raw_params = self.get_raw_params(img=img)

        aug_img = self.apply_transform(img=img, params=local_raw_params)

        local_proc_params = self.post_process_params(img=img, params=local_raw_params)

        concat_proc_params = Transform.concat_params(params, local_proc_params)

        return aug_img, concat_proc_params

    @abstractmethod
    def get_raw_params(self, img: IMAGE_TYPE) -> PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """

    @abstractmethod
    def apply_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE, **kwargs
    ) -> IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """

    @abstractmethod
    def post_process_params(self, img: IMAGE_TYPE, params: PARAM_TYPE) -> PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """

    def consume_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        This method consists of 4 steps--
        1. Detach processed parameters from the input parameters.
        2. Pre-process the processed parameters to get local raw parameters.
        3. Generate augmentation from the data point and local raw parameters.
        4. Return augmented data point along with remaining parameters.
        """
        local_proc_params, rem_proc_params = self.extract_params(params=params)

        local_raw_params = self.pre_process_params(img=img, params=local_proc_params)

        aug_img = self.apply_transform(img=img, params=local_raw_params)

        return aug_img, rem_proc_params

    @abstractmethod
    def extract_params(self, params: PARAM_TYPE) -> t.Tuple[PARAM_TYPE, PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """

    @abstractmethod
    def pre_process_params(self, img: IMAGE_TYPE, params: PARAM_TYPE) -> PARAM_TYPE:
        """Pre-processes the parameters of augmentations.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """

        return f"{self.name}()"


class ComposingTransform(Transform):
    """Defines the base for a composing transform. These transforms are
    intended to input one or more underlying transforms and use their
    functionality to achieve the intended composing behavior.
    """

    def __init__(self, *args, **kwargs) -> None:
        """The initializer.

        :param args: The arguments for the underlying transform.
        :param kwargs: The keyword arguments for the underlying transform.

        The implementing subclass should define `transforms` and `tx_mode`.

        :arg transforms: The list, tuple, or any other iterable object that
            can produce all the component transforms in the correct order.
        :arg tx_mode: The mode of the transform.
        """

        super(ComposingTransform, self).__init__(*args, **kwargs)

    def cascade_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Inputs the data point and previous parameters, generates the
        parameters for the current transform, augments the data point with the
        current parameters, concatenates previous parameters with the current
        and augmentation parameters, and returns the concatenated parameters.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.

        This method consists of 5 steps--
        1. Generate raw parameters for the composing transform.
        2. Generate the augmentation from the data point and local parameters
            to get augmentation and corresponding augmentation parameters.
        3. Post-process the raw local and augmentation parameters.
        4. Attach processed versions of the local parameters and the
            augmentation parameters to those input to this method.
        5. Return the augmented data point and combined processed parameters.
        """
        local_raw_params = self.get_raw_params(img=img)

        aug_img, aug_params = self.apply_cascade_transform(
            img=img, params=local_raw_params
        )

        local_proc_params, aug_proc_params = self.post_process_params(
            img=img, params=local_raw_params, aug_params=aug_params
        )

        concat_proc_params = Transform.concat_params(
            params, local_proc_params, aug_proc_params
        )

        return aug_img, concat_proc_params

    @abstractmethod
    def get_raw_params(self, img: IMAGE_TYPE) -> PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """

    @abstractmethod
    def apply_cascade_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE, **kwargs
    ) -> TRANSFORM_RETURN_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image and corresponding augmentation parameters.

        Here, the returned augmentation parameters are the ones generated by
        the application of the core transforms in `self.transforms`.
        """

    @abstractmethod
    def post_process_params(
        self,
        img: IMAGE_TYPE,
        params: PARAM_TYPE,
        aug_params: PARAM_TYPE,
    ) -> t.Tuple[PARAM_TYPE, PARAM_TYPE]:
        """Post-processes the local and augmentation parameters.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.
        :param aug_params: The processed params from the composition of the
            core transforms of this composing transform.

        :returns: The post-processed local and augmentation parameters.
        """

    def consume_transform(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> TRANSFORM_RETURN_TYPE:
        """Inputs the data point and parameters, extracts the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        This method consists of 4 steps--
        1. Detach local processed parameters from the input parameters.
        2. Pre-process the local post-processed parameters.
        3. Generate augmentation from the data point and local parameters.
        4. Return augmented data point along with the remaining parameters.
        """
        concat_proc_params, rem_proc_params = self.extract_params(params=params)

        local_raw_params, aug_params = self.pre_process_params(
            img=img, params=concat_proc_params
        )

        aug_img, rem_aug_params = self.apply_consume_transform(
            img=img, params=local_raw_params, aug_params=aug_params
        )

        assert len(rem_aug_params) == 0, (
            f"ERROR | Transformations:\n{str(self)}\ndid NOT consume "
            "ALL of the local processed parameters.\n"
            f"The local processed parameters are: {concat_local_params}.\n"
            f"The remaining parameters are: {rem_aug_params}."
        )

        return aug_img, rem_proc_params

    @abstractmethod
    def extract_params(self, params: PARAM_TYPE) -> t.Tuple[PARAM_TYPE, PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """

    @abstractmethod
    def pre_process_params(
        self, img: IMAGE_TYPE, params: PARAM_TYPE
    ) -> t.Tuple[PARAM_TYPE, PARAM_TYPE]:
        """Pre-processes the parameters of augmentations.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """

    @abstractmethod
    def apply_consume_transform(
        self,
        img: IMAGE_TYPE,
        params: PARAM_TYPE,
        aug_params: PARAM_TYPE,
    ) -> TRANSFORM_RETURN_TYPE:
        """Applies the transform with given parameters by consuming them.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.
        :param aug_params: The parameters from composition of parameterized transforms.

        :returns: The augmented image with the remaining parameters.
        """
