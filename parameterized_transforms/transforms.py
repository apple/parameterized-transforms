"""
Copyright 2025 Apple Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""


"""
Credits
-------
The aim of the package is to provide parameterized versions of transforms from
`torchvision`. For this, we want to maintain parity in implementation, which
necessitates borrowing code from `torchvision`. The borrowed code comes from:
https://github.com/pytorch/vision/blob/main/torchvision/transforms/transforms.py

Individual classes will provide more information on borrowed code.
"""


import typing as t

import numpy as np
import torch
import torchvision.transforms as tvtx
import torchvision.transforms.functional as tv_fn

import parameterized_transforms.core as ptc
import parameterized_transforms.utils as ptu

# --------------------------------------------------------------------------------
# Atomic transforms from `torchvision`.
# --------------------------------------------------------------------------------


class ToTensor(ptc.AtomicTransform, tvtx.ToTensor):
    """Convert `HWC`-shaped, `[0, 255]`-ranged, and `uint8` typed `PIL` image
    or `numpy` array into `CHW`-shaped `[0.0, 1.0]`-ranged tensor.
    """

    def __init__(
        self, tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE
    ) -> None:
        """
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """
        super(ToTensor, self).__init__(tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """
        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.ToTensor.__call__(self, pic=img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class PILToTensor(ptc.AtomicTransform, tvtx.PILToTensor):
    """Converts a `PIL`-image in `HWC` format to a tensor in `CHW` format.
    This tensor is NOT normalized, has `dtype` as `torch.uint8`, and has
    values is in the range `[0, 255]`.
    """

    def __init__(
        self, tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE
    ) -> None:
        """
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(PILToTensor, self).__init__(tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.PILToTensor.__call__(self, pic=img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class ConvertImageDtype(ptc.AtomicTransform, tvtx.ConvertImageDtype):
    """Converts a torch tensor to a given data type."""

    def __init__(
        self,
        dtype: torch.dtype,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param dtype: The data type to which to convert the input.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(ConvertImageDtype, self).__init__(dtype=dtype, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.ConvertImageDtype.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"dtype={self.dtype}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class ToPILImage(ptc.AtomicTransform, tvtx.ToPILImage):
    """Converts the input tensor to a PIL image. The shape is changed from
    `CHW` format to `HWC` format BUT THE VALUE RANGE IS PRESERVED.
    """

    def __init__(
        self,
        mode: t.Optional[str] = None,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param mode: The mode of the input image. Please check the
            documentation of `tvtx.ToPILImage` to see its details.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(ToPILImage, self).__init__(mode=mode, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.ToPILImage.__call__(self, pic=img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"mode={self.mode}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class Normalize(ptc.AtomicTransform, tvtx.Normalize):
    """Normalizes the input tensors to given mean and standard deviation. This
    normalization is performed on a per-channel basis; check the docs of
    `tvtx.Normalize` for more details.
    """

    def __init__(
        self,
        mean: torch.Tensor,
        std: torch.Tensor,
        inplace: bool = False,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param mean: The mean with which to normalize the input tensor.
        :param std: The standard deviation with which to normalize the input tensor.
        :param inplace: Whether to normalize the data in-place.
            DEFAULT: `False`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.

        Note that the required `mean` and `std` are intended to have `n`
        entries, where  `n` is the number of channels in the input images.
        Thus, this is not a batch transform; it updates all entries in a batch
        with the same `mean` and `std` defined in the initializer.
        """

        super(Normalize, self).__init__(
            mean=mean, std=std, inplace=inplace, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: torch.Tensor, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.Normalize.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: torch.Tensor, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"mean={self.mean}, "
            f"std={self.std}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class Resize(ptc.AtomicTransform, tvtx.Resize):
    """Resizes the input image to the given size.

    Note that if the image is `PIL`-image, the interpolation uses
    anti-aliasing whereas the `torch` tensors do not. Thus, there can be a
    performance difference in case resizing is not done consistently. If you
    wish to use `TorchScript` on this augmentation, `size` should always be a
    `list`; if `size` is a single integer, convert it to a `list` of length
    one; i.e., `size = 3` becomes `size = [3, ]`.
    """

    def __init__(
        self,
        size: t.Union[int, t.Iterable],
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.BILINEAR,
        max_size: t.Optional[int] = None,
        antialias: t.Optional[bool] = None,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The size to which to resize to. Note that if `size` is
            an `int`, it is mapped to a tuple such that the smaller side of
            the image now becomes equal to this size.
        :param interpolation: The interpolation method. For tensors, the
            supported modes are `BILINEAR`, `NEAREST`, `BICUBIC`.
        :param max_size: The maximum size allowed for the longer side. If
            after the resize is complete, an edge is still longer than this
            `max_size`, it is rescaled again, effectively overriding `size`.
            This is only supported when `size` is an int or 1-long sequence.
        :param antialias: Whether to use antialiasing. If the input is a `PIL`
            image, it is always converted with anti-alias. If the input turns
            out to be a tensor, this flag is `False` by default and needs to
            be explicitly set to `True`. This `True` value will only be
            considered for `BILINEAR` and `BICUBIC` modes, which allows to
            make the `torch` output match closer to the `PIL` equivalent.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """
        super(Resize, self).__init__(
            size=size,
            interpolation=interpolation,
            max_size=max_size,
            antialias=antialias,
            tx_mode=tx_mode,
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.Resize.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"interpolation={self.interpolation}, "
            f"max_size={self.max_size}, "
            f"antialias={self.antialias}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class CenterCrop(ptc.AtomicTransform, tvtx.CenterCrop):
    """Creates a crop of the image at the center, with the given size. If the
    image size is smaller than the required crop size, the image is first
    padded with 0's till the size is clear and then, it is cropped.
    """

    def __init__(
        self,
        size: t.Union[int, t.List[int], t.Tuple[int, int]],
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The required crop size. If integer, the crop shape is
            `[size, size]`. If a list or a tuple of length 2, that is the
            shape of the crop. If a single element list or tuple is given,
            the shape is `[size[0], size[0]]`. Other types are not valid.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """
        super(CenterCrop, self).__init__(size=size, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.CenterCrop.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class Pad(ptc.AtomicTransform, tvtx.Pad):
    """Pads the input image with a given value of padding. For the details of
    shape of the input data, please check the docs of `tvtx.Pad`.
    """

    def __init__(
        self,
        padding: t.Union[
            int, t.List[int], t.Tuple[int, int], t.Tuple[int, int, int, int]
        ],
        fill: t.Union[int, t.List[int], t.Tuple[int, int]] = 0,
        padding_mode: str = "constant",
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param padding: The value to be padded on each of the borders. If a
            single int is provided, it is used to pad all borders. If a
            list/tuple of two values is given, it is the padding for the
            left/right and top/bottom borders. If a list/tuple of four values
            is given, it is padding for the left, top, right, bottom borders.
        :param fill: The pixel value for the fill.
            DEFAULT: 0.
            This value is only used for `constant` padding mode. If it is a
            list/tuple of length 3, it is used as RBG values for the padding.
            For tensor data, only numbers are supported. For `PIL` images,
            only int or tuple values are supported.
        :param padding_mode: The type of padding.
            SUPPORTS: `constant`, `edge`, `reflect`, `symmetric`.
            For `constant`, the `fill` value is used to pad the input. For
            `edge`, the edges of the image are extended out to pad. For
            `reflect`, the border values are reflected out into the padding.
            For `symmetric`, the padding is equivalent to repeating the image
            at its edge and then taking an appropriate crop. For more details,
            check docs of `tvtx.Pad`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(Pad, self).__init__(
            padding=padding, fill=fill, padding_mode=padding_mode, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.Pad.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"padding={self.padding}, "
            f"fill={self.fill}, "
            f"padding_mode={self.padding_mode}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class Lambda(ptc.AtomicTransform, tvtx.Lambda):
    """Implements a lambda function to enable user-defined transforms."""

    def __init__(
        self,
        lambd: t.Callable,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param lambd: The lambda function to be set for the transform.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(Lambda, self).__init__(lambd=lambd, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.Lambda.__call__(self, img=img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"lambd=Function({self.lambd}), "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomCrop(ptc.AtomicTransform, tvtx.RandomCrop):
    """Crops the image at a random location. For details of image shape,
    please check the docs of `tvtx.RandomCrop`.
    """

    def __init__(
        self,
        size: t.Union[int, t.List[int], t.Tuple[int, int]],
        padding: t.Optional[t.Union[int, t.List[int], t.Tuple]] = None,
        pad_if_needed: bool = False,
        fill: t.Union[int, t.List[int], t.Tuple] = 0,
        padding_mode: str = "constant",
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The required size of the crop. If it is an `int`, the
            shape of the crop is `[size, size]`. If a list/tuple/iterable of
            length 1, the shape is `[size[0], size[0]]`. If a list/tuple, its
            length must be 2 and the shape of the crop matches `size`.
        :param padding: The details to pad each border. If a single `int`, it
            is used to pad all borders. If two `int`s, they are the paddings
            for the left/right and top/bottom borders. If four `int`s, they
            are the paddings for the left, top, right, bottom borders. In
            `TorchScript`, a single `int` input here is not supported.
            Instead, used a sequence of length 1, i.e., `size = 3` becomes
            `size = [3, ]`.
            DEFAULT: `None`
        :param pad_if_needed: Pad an image if the required `size` is larger
            than the image size. Otherwise, an exception will be raised. NOTE
            THAT THE CROPPING WILL FOLLOW THE PADDING and so, padding at the
            borders of the cropped image can be different on different edges.
            DEFAULT: `False`.
        :param fill: The value to be used to fill up the padded region.
            DEFAULT: 0.
            If the input is an `int`, it is set at all channels of the input.
            If a sequence of length 3, the three values are used to fill up
            the RGB channels in the padded region. This `fill` value is only
            used when the `padding_mode` is `constant`. Only `tuple` or `int`
            is supported for `PIL` images. Only numbers supported for tensors.
        :param padding_mode: The type of padding to apply.
            SUPPORTS: `constant`, `edge`, `reflect`, `symmetric`.
            If `constant`, the `fill` value above is used to fill in the
            padded region. If `edge`, the `edge` pixels are padded with the
            last values at the edges. If `reflect`, the images are reflected
            at the edges to fill in the padded region. If `symmetric`, the
            image is tiled repeatedly and a cropped at the required size.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.

        For further details, check the docs of `tvtx.RandomCrop`.

        # Here, there are 4 params-- `(x, y)` of start and `(h, w)` of crop.
        self.param_count: int = 4
        """
        super(RandomCrop, self).__init__(
            size=size,
            padding=padding,
            pad_if_needed=pad_if_needed,
            fill=fill,
            padding_mode=padding_mode,
            tx_mode=tx_mode,
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 4

    def cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and previous parameters, generate the parameters
        for the current transform, augment previous parameters with current
        parameters, and return the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `RandomCrop` transform of `torchvision`, we borrow code from `forward`
        method of `RandomCrop` class.
        """

        # Pad the image if the details are given.
        if self.padding is not None:
            img = tv_fn.pad(
                img=img,
                padding=self.padding,
                fill=self.fill,
                padding_mode=self.padding_mode,
            )

        # Get the dimensions of the image.
        width, height = tv_fn.get_image_size(img)

        # If needed, pad width.
        if self.pad_if_needed and width < self.size[1]:
            padding = [self.size[1] - width, 0]
            img = tv_fn.pad(img, padding, self.fill, self.padding_mode)

        # If needed, pad height.
        if self.pad_if_needed and height < self.size[0]:
            padding = [0, self.size[0] - height]
            img = tv_fn.pad(img, padding, self.fill, self.padding_mode)

        return super(RandomCrop, self).cascade_transform(img=img, params=params)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        i, j, h, w = self.get_params(img, self.size)
        return (i, j, h, w)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        i, j, h, w = params
        return tv_fn.crop(img, i, j, h, w)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def consume_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `RandomCrop` transform of `torchvision`, we borrow code from `forward`
        method of `RandomCrop` class.
        """

        # Pad the image if the details are given.
        if self.padding is not None:
            img = tv_fn.pad(
                img=img,
                padding=self.padding,
                fill=self.fill,
                padding_mode=self.padding_mode,
            )

        # Get the dimensions of the image.
        width, height = tv_fn.get_image_size(img)

        # If needed, pad width.
        if self.pad_if_needed and width < self.size[1]:
            padding = [self.size[1] - width, 0]
            img = tv_fn.pad(img, padding, self.fill, self.padding_mode)

        # If needed, pad height.
        if self.pad_if_needed and height < self.size[0]:
            padding = [0, self.size[0] - height]
            img = tv_fn.pad(img, padding, self.fill, self.padding_mode)

        return super(RandomCrop, self).consume_transform(img=img, params=params)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        width, height = tv_fn.get_image_size(img=img)
        raw_id_params = (0, 0, height, width)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"padding={self.padding}, "
            f"pad_if_needed={self.pad_if_needed}, "
            f"fill={self.fill}, "
            f"padding_mode={self.padding_mode}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomHorizontalFlip(ptc.AtomicTransform, tvtx.RandomHorizontalFlip):
    """Flips the image horizontally at random with a given probability."""

    def __init__(
        self,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to flip.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomHorizontalFlip, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.hflip(img=img)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomVerticalFlip(ptc.AtomicTransform, tvtx.RandomVerticalFlip):
    """Flips the image vertically at random with a given probability."""

    def __init__(
        self,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to flip.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomVerticalFlip, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.vflip(img=img)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomPerspective(ptc.AtomicTransform, tvtx.RandomPerspective):
    """Generates a random perspective projection of the given image with a
    given probability.
    """

    def __init__(
        self,
        distortion_scale: float = 0.5,
        p: float = 0.5,
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.BILINEAR,
        fill: t.Union[int, t.List[int], t.Tuple] = 0,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param distortion_scale: The scale of image distortion. Check the docs
            of `tvtx.RandomPerspective` to track its meaning. In
            brief, this scale factor is used in defining the end-points of the
            perspective that needs to be generated.
        :param p: The probability with which to apply this transform.
        :param interpolation: The interpolation method to fill-in pixels.
            SUPPORTS: `Enum` defined with `tv_fn.InterpolationMode`, which in
            turn supports the following-- 'NEAREST', 'BILINEAR', 'BICUBIC',
            'BOX', 'HAMMING', 'LANCZOS'.
        :param fill: The fill value to be used for gaps left in perspective.
            If a number, it is used to fill in all channels. Else, the
            sequence is used to fill in the channel values.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """
        super(RandomPerspective, self).__init__(
            distortion_scale=distortion_scale,
            p=p,
            interpolation=interpolation,
            fill=fill,
        )

        # Define a field to keep track of current fill values per forward pass.
        self.current_fill = None

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 16

    def cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and previous parameters, generate the parameters
        for the current transform, augment previous parameters with current
        parameters, and return the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `RandomPerspective` transform of `torchvision`, we borrow code from
        `forward` method of `RandomPerspective` class.
        """

        fill = self.fill

        # If the image is a torch tensor, correct the fill for all channels.
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(
                    img=img
                )
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstsance(img, Image.Image) == True`
            self.current_fill = fill

        local_raw_params = self.get_raw_params(img=img)

        aug_img, local_raw_params = self.apply_transform(
            img=img, params=local_raw_params
        )

        local_proc_params = self.post_process_params(img=img, params=local_raw_params)

        concat_proc_params = ptc.Transform.concat_params(params, local_proc_params)

        return aug_img, concat_proc_params

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """

        width, height = tv_fn.get_image_size(img)
        startpoints, endpoints = self.get_params(width, height, self.distortion_scale)

        if torch.rand(1) < self.p:
            return (startpoints, endpoints)

        return (startpoints, startpoints)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """

        fill: t.List[float] = self.current_fill

        # If the corners need to be mapped to themselves, return same image.
        if params[0] == params[1]:
            return img, params

        try:
            return (
                tv_fn.perspective(
                    img=img,
                    startpoints=params[0],
                    endpoints=params[1],
                    interpolation=self.interpolation,
                    fill=fill,
                ),
                params,
            )
        # Fix for `torch._C._LinAlgError`; resample params to get augmentation.
        # Note that this `except` catch does indeed get executed and is tested!
        except torch._C._LinAlgError as e:  # noqa
            print(
                f"WARNING | Resampling parameters in `apply_transform` of "
                f"`RandomPerspective` due to exception in `tv_fn.perspective`."
            )
            new_params = self.get_raw_params(img=img)
            return self.apply_transform(img=img, params=new_params)
        except Exception as e:
            raise RuntimeError(
                f"ERROR | `RandomPerspective` resulted in " f"unexpected error: {e}"
            )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (
            *tuple([elt for a_sublist in params[0] for elt in a_sublist]),
            *tuple([elt for a_sublist in params[1] for elt in a_sublist]),
        )

    def consume_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `RandomPerspective` transform of `torchvision`, we borrow code from
        `forward` method of `RandomPerspective` class.
        """

        fill = self.fill

        # If the image is a torch tensor, correct the fill for all channels.
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(
                    img=img
                )
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstsance(img, Image.Image) == True`
            self.current_fill = fill

        local_proc_params, rem_proc_params = self.extract_params(params=params)

        local_raw_params = self.pre_process_params(img=img, params=local_proc_params)

        aug_img, ret_local_raw_params = self.apply_transform(
            img=img, params=local_raw_params
        )

        assert local_raw_params == ret_local_raw_params, (
            f"ERROR | Input parameters: {local_raw_params} to "
            f"`consume_transform` of `RandomPerspective` lead to exception in "
            f"`apply_transform`, leading to resampling; "
            f"ensure that given parameters are consistent."
        )

        return aug_img, rem_proc_params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        startpoints = [
            [params[0], params[1]],
            [params[2], params[3]],
            [params[4], params[5]],
            [params[6], params[7]],
        ]
        endpoints = [
            [params[8], params[9]],
            [params[10], params[11]],
            [params[12], params[13]],
            [params[14], params[15]],
        ]
        return (startpoints, endpoints)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        width, height = tv_fn.get_image_size(img=img)
        startpoints = [[0, 0], [width - 1, 0], [width - 1, height - 1], [0, height - 1]]
        endpoints = startpoints
        raw_id_params = (startpoints, endpoints)

        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"distortion_scale={self.distortion_scale}, "
            f"p={self.p}, "
            f"interpolation={self.interpolation}, "
            f"fill={self.fill}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomResizedCrop(ptc.AtomicTransform, tvtx.RandomResizedCrop):
    """Creates a randomly selected crop of the given image."""

    def __init__(
        self,
        size: t.Union[int, t.List[int], t.Tuple[int, int]],
        scale: t.Union[t.List[float], t.Tuple[float, float]] = (0.08, 1.0),
        ratio: t.Union[t.List[float], t.Tuple[float, float]] = (3.0 / 4.0, 4.0 / 3.0),
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.BILINEAR,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The output size of the crop. If `int`, the shape of the
            crop is `[size, size]`. If it is a sequence of length 1, the shape
            of the crop is `[size[0], size[0]]`. Otherwise, it is a list or
            tuple, it must be of length 2, and it gives the shape of the crop.
        :param scale: The lower and upper bounds to the ratio of the area of
            the crop in the original image to the area of the entire image.
            DEFAULT: `(0.08, 1.0)`.
        :param ratio: Lower and upper bounds on the aspect ratio of the crop.
            DEFAULT: `(3.0/4.0, 4.0/3.0)`.
        :param interpolation: The interpolation method to be used for crop.
            SUPPORTS: `Enum` defined with `tv_fn.InterpolationMode`, which in
            turn supports the following-- 'NEAREST', 'BILINEAR', 'BICUBIC',
            'BOX', 'HAMMING', 'LANCZOS'.
            DEFAULT: `tv_fn.InterpolationMode.BILINEAR`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.

        The parameter below seems to be added/deprecated.
        :deprecated antialias: Whether to use antialiasing in reshaping
            images. If the input is a `PIL`-image, antialiasing is always used
            and this flag is ignored. For tensor input, the flag is `False` by
            default and needs to be set to `True` for `BILINEAR` or `BICUBIC`.
        """

        super(RandomResizedCrop, self).__init__(
            size=size,
            scale=scale,
            ratio=ratio,
            interpolation=interpolation,
            tx_mode=tx_mode,
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 4

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        i, j, h, w = self.get_params(img=img, scale=self.scale, ratio=self.ratio)
        return (i, j, h, w)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        i, j, h, w = params
        return tv_fn.resized_crop(
            img=img,
            top=i,
            left=j,
            height=h,
            width=w,
            size=self.size,
            interpolation=self.interpolation,
        )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        width, height = tv_fn.get_image_size(img=img)
        raw_id_params = (0, 0, height, width)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"scale={self.scale}, "
            f"ratio={self.ratio}, "
            f"interpolation={self.interpolation}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class FiveCrop(ptc.AtomicTransform, tvtx.FiveCrop):
    """Crops the image into its 4 corners and its central crops."""

    def __init__(
        self,
        size: t.Union[int, t.List[int], t.Tuple[int, int]],
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The desired size of the crops. If `int`, the shape of the
            crop is `[size, size]`. If a sequence of length 1, the shape is
            `[size[0], size[0]]`. If a list/tuple/sequence, the length should
            be 2 and then, that is the shape of the crop.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(FiveCrop, self).__init__(size=size, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.FiveCrop.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"tx_mode={self.tx_mode}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class TenCrop(ptc.AtomicTransform, tvtx.TenCrop):
    """Crops the image into its 4 corners and central crop, along with the
    flipped versions of these 5 crops.
    """

    def __init__(
        self,
        size: t.Union[int, t.List[int], t.Tuple[int, int]],
        vertical_flip: bool = False,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param size: The desired size of the crops. If `int`, the shape of the
            crop is `[size, size]`. If a sequence of length 1, the shape is
            `[size[0], size[0]]`. If a list/tuple/sequence, the length should
            be 2 and then, that is the shape of the crop.
        :param vertical_flip: Whether to flip the image vertically.
            DEFAULT: `False`, as by default, the flip is horizontal.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(TenCrop, self).__init__(
            size=size, vertical_flip=vertical_flip, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.TenCrop.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"size={self.size}, "
            f"vertical_flip={self.vertical_flip}, "
            f"tx_mode={self.tx_mode}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class LinearTransformation(ptc.AtomicTransform, tvtx.LinearTransformation):
    """Applies a linear transform to the input image, which is defined as the
    flattening of the input data point, followed by the subtraction of the
    mean followed by matrix multiplication with the given matrix, followed by
    the reshaping to the original shape.
    """

    def __init__(
        self,
        transformation_matrix: torch.Tensor,
        mean_vector: torch.Tensor,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param transformation_matrix: A square matrix of the shape `[D, D]`,
            where `D = C*H*W`, the size of the flattened image.
        :param mean_vector: A vector of shape `[D, ]`, with `D = C*H*W`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(LinearTransformation, self).__init__(
            transformation_matrix=transformation_matrix,
            mean_vector=mean_vector,
            tx_mode=tx_mode,
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.LinearTransformation.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"transformation_matrix={self.transformation_matrix}, "
            f"mean_vector={self.mean_vector}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class ColorJitter(ptc.AtomicTransform, tvtx.ColorJitter):
    """Perturbs the brightness, contrast, saturation, and hue of the given
    input in a random order and returns the resulting image.
    """

    def __init__(
        self,
        brightness: t.Union[float, t.List[float], t.Tuple[float, float]] = 0,
        contrast: t.Union[float, t.List[float], t.Tuple[float, float]] = 0,
        saturation: t.Union[float, t.List[float], t.Tuple[float, float]] = 0,
        hue: t.Union[float, t.List[float], t.Tuple[float, float]] = 0,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
        default_params_mode: ptc.DefaultParamsMode = ptc.DefaultParamsMode.RANDOMIZED,
    ) -> None:
        """
        :param brightness: The amount by which to perturb the brightness. If
            `float`, the min and max amounts are set as
            `max(0, 1 - brightness)` and `1 + brightness` respectively. Else,
            the list/tuple must be of length 2, and it is treated as the
            sequence of the min and the max values for the same. A uniform
            sample from this range is taken as the brightness factor. The
            value must be non-negative.
        :param contrast: The amount by which to perturb the contrast. If
            `float`, the min and max amounts are set as
            `max(0, 1 - contrast)` and `1 + contrast` respectively. Else, the
            list/tuple must be of length 2, and it is treated as the sequence
            of the min and the max values for the same. A uniform sample from
            this range is taken as the contrast factor. The value must be
            non-negative.
        :param saturation: The amount by which to perturb the saturation. If
            `float`, the min and max amounts are set as
            `max(0, 1 - saturation)` and `1 + saturation` respectively. Else,
            the list/tuple must be of length 2, and it is treated as the
            sequence of the min and the max values for the same. A uniform
            sample from this range is taken as the contrast factor. The value
            must be non-negative.
        :param hue: The amount by which to perturb the hue. If `float`, the
            min and max amounts are set as `-hue` and `hue` respectively. Else,
            the list/tuple must be of length 2, and it is treated as the
            sequence of the min and the max values for the same. A uniform
            sample from this range is taken as the hue factor. The value of
            `hue` must lead to `0 <= hue <= 0.5` or
            `-0.5 <= max <= max <= 0.5`. Ensure that the image is augmented so
            that the pixel values are non-negative. This will not work in
            pixel values are negative as conversion to the HSV space fails.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        :param default_params_mode: The mode of the default params.
            SUPPORT: `ptc.DefaultParamsMode.{UNIQUE,RANDOMIZED}`.
            DEFAULT: `ptc.DefaultParamsMode.RANDOMIZED`.

        To check the effect of the normalization to a range containing
        negative values, refer to the docs of `tvtx.ColorJitter`.
        """

        super(ColorJitter, self).__init__(
            brightness=brightness,
            contrast=contrast,
            saturation=saturation,
            hue=hue,
            tx_mode=tx_mode,
        )

        # Revert `None` defaults in `torchvision` to appropriate tuples.
        self._revert_None_defaults_to_numeric_values()

        self.default_params_mode = default_params_mode

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 8

    def _revert_None_defaults_to_numeric_values(self) -> None:
        """Reverts the default `None` values of the major attributes to
        appropriate numerical values in order to avoid `None` parameters.
        """
        self.brightness = [1.0, 1.0] if self.brightness is None else self.brightness
        self.contrast = [1.0, 1.0] if self.contrast is None else self.contrast
        self.saturation = [1.0, 1.0] if self.saturation is None else self.saturation
        self.hue = [0.0, 0.0] if self.hue is None else self.hue

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        params = self.get_params(
            self.brightness, self.contrast, self.saturation, self.hue
        )
        return params

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `ColorJitter` transform of `torchvision`, we borrow code from
        `forward` method of `ColorJitter` class.
        """
        (
            fn_idx,
            brightness_factor,
            contrast_factor,
            saturation_factor,
            hue_factor,
        ) = params

        for fn_id in fn_idx:
            if fn_id == 0 and brightness_factor is not None:
                img = tv_fn.adjust_brightness(img, brightness_factor)
            elif fn_id == 1 and contrast_factor is not None:
                img = tv_fn.adjust_contrast(img, contrast_factor)
            elif fn_id == 2 and saturation_factor is not None:
                img = tv_fn.adjust_saturation(img, saturation_factor)
            elif fn_id == 3 and hue_factor is not None:
                if hue_factor != 0:
                    img = tv_fn.adjust_hue(img, hue_factor)
                else:
                    pass

        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        (
            fn_idx,
            brightness_factor,
            contrast_factor,
            saturation_factor,
            hue_factor,
        ) = params
        return tuple(fn_idx.view(-1).tolist()) + (
            brightness_factor,
            contrast_factor,
            saturation_factor,
            hue_factor,
        )

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        fn_idx = tuple(params[:4])
        brightness, contrast, saturation, hue = params[4:]
        return (fn_idx, brightness, contrast, saturation, hue)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        if self.default_params_mode == ptc.DefaultParamsMode.RANDOMIZED:
            ordering = torch.tensor(
                np.random.permutation(np.arange(4)).astype(np.uint8)
            )
        else:
            ordering = torch.tensor([0, 1, 2, 3], dtype=torch.int8)

        raw_id_params = (
            ordering,
            1.0,
            1.0,
            1.0,
            0.0,
        )
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"ColorJitter("
            f"  brightness={self.brightness}, "
            f"  contrast={self.contrast}, "
            f"  saturation={self.saturation}, "
            f"  hue={self.hue}, "
            f"  param_count={self.param_count}, "
            f"  tx_mode={self.tx_mode}"
            f")"
        )


class RandomRotation(ptc.AtomicTransform, tvtx.RandomRotation):
    """Rotates the image by a randomly chosen angle."""

    def __init__(
        self,
        degrees: t.Union[
            float,
            int,
            t.List[float],
            t.List[int],
            t.Tuple[float, float],
            t.Tuple[int, int],
        ],
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.NEAREST,
        expand: bool = False,
        center: t.Optional[t.Union[t.List[int], t.Tuple[int]]] = None,
        fill: t.Union[int, t.List[int], t.Tuple] = 0,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param degrees: The range from which to choose the rotation angle. If a
            number is given, the range is `[-degrees, degrees]`. Else, the
            list/tuple must be of length 2, which represents the min and max
            angles of rotation.
        :param interpolation: The interpolation method to be used for image.
            SUPPORTS: `Enum` defined with `tv_fn.InterpolationMode`, which in
            turn supports the following-- 'NEAREST', 'BILINEAR', 'BICUBIC',
            'BOX', 'HAMMING', 'LANCZOS'.
            DEFAULT: `tv_fn.InterpolationMode.NEAREST`.
        :param expand: Whether to expand the image so that the output image
            holds the entire rotated image.
            DEFAULT: `False`.
            If `False`, rotated image is the same size as the input image.
        :param center: The center of the rotation.
            DEFAULT: `None`.
            If `None`, then it is set to the image center.
        :param fill: The fill value for the region in the output outside the
            rotated image. If a number, it is used to fill all channels.
            Otherwise, a list/tuple of the same size as the number of channels
            needs to be provided as the pixel value in the outside region.
            DEFAULT: `0`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomRotation, self).__init__(
            degrees=degrees,
            interpolation=interpolation,
            expand=expand,
            center=center,
            fill=fill,
            tx_mode=tx_mode,
        )

        self.current_fill = None

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and previous parameters, generate the parameters
        for the current transform, augment previous parameters with current
        parameters, and return the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.

        Credits:
        1. To maintain parity with pre-processing of the image data in
        `RandomRotation` transform of `torchvision`, we borrow code from `forward`
        method of `RandomRotation` class.
        """

        fill = self.fill
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(
                    img=img
                )
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstsance(img, Image.Image) == True`
            self.current_fill = fill

        return super(RandomRotation, self).cascade_transform(img=img, params=params)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        angle = self.get_params(self.degrees)
        return (angle,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """

        fill: t.List[float] = self.current_fill

        return tv_fn.rotate(
            img=img, angle=params[0], expand=self.expand, center=self.center, fill=fill
        )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def consume_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        1. To maintain parity with pre-processing of the image data in
        `RandomRotation` transform of `torchvision`, we borrow code from `forward`
        method of `RandomRotation` class.
        """

        fill = self.fill
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(
                    img=img
                )
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstsance(img, Image.Image) == True`
            self.current_fill = fill

        return super(RandomRotation, self).consume_transform(img=img, params=params)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (0.0,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"degrees={self.degrees}, "
            f"interpolation={self.interpolation}, "
            f"expand={self.expand}, "
            f"center={self.center}, "
            f"fill={self.fill}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomAffine(ptc.AtomicTransform, tvtx.RandomAffine):
    """Performs a random affine transformation of the image such that the
    center is invariant to the transform.
    """

    def __init__(
        self,
        degrees: t.Union[
            float,
            int,
            t.List[float],
            t.List[int],
            t.Tuple[float, float],
            t.Tuple[int, int],
        ],
        translate: t.Optional[t.Tuple[float, float]] = None,
        scale: t.Optional[t.Tuple[t.Union[int, float], t.Union[int, float]]] = None,
        shear: t.Optional[
            t.Union[
                int, float, t.List[t.Union[int, float]], t.Tuple[t.Union[int, float]]
            ]
        ] = None,
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.NEAREST,
        fill: t.Union[int, t.List[int], t.Tuple] = 0,
        center: t.Optional[t.Union[t.List[int], t.Tuple[int]]] = None,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param degrees: The range from which to choose the rotation angle. If a
            number is given, the range is `[-degrees, degrees]`. Else, the
            list/tuple must be of length 2, which represents the min and max
            angles of rotation.
        :param translate: The tuple of FRACTIONS by which to translate the
            image along the width and along the height dimensions.
            DEFAULT: `None`, which means no translation.
        :param scale: The lower and upper bounds of the factor by which to
            scale the image.
            DEFAULT: `None`, which means no scaling.
        :param shear: The angle by which to shear. If a number, a shear within
            the range `(-shear, shear)` is applied along the x-axis. If a
            list/tuple, the length should be 2 or 4. If length 2, a shear
            value in range `(shear[0], shear[1])` is applied to the x-axis.
            If length 4, a shear value in range `(shear[0], shear[1])` is
            applied to the x-axis and a shear value in range
            `(shear[2], shear[3])` is applied to the y-axis.
            DEFAULT: `None`, which means no shearing.
        :param interpolation: The interpolation method to be used for image.
            SUPPORTS: `Enum` defined with `tv_fn.InterpolationMode`, which in
            turn supports the following-- 'NEAREST', 'BILINEAR', 'BICUBIC',
            'BOX', 'HAMMING', 'LANCZOS'.
            DEFAULT: `tv_fn.InterpolationMode.NEAREST`.
        :param fill: The fill value for the region in the output outside the
            rotated image. If a number, it is used to fill all channels.
            Otherwise, a list/tuple of the same size as the number of channels
            needs to be provided as the pixel value in the outside region.
            DEFAULT: `0`.
        :param center: The center of the rotation.
            DEFAULT: `None`.
            If `None`, then it is set to the image center.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomAffine, self).__init__(
            degrees=degrees,
            translate=translate,
            scale=scale,
            shear=shear,
            interpolation=interpolation,
            fill=fill,
            center=center,
            tx_mode=tx_mode,
        )

        self.current_fill = None

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 6

    def cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Implements the forward pass with dunder call.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.

        1. To maintain parity with pre-processing of the image data in
        `RandomAffine` transform of `torchvision`, we borrow code from `forward`
        method of `RandomAffine` class.
        """

        fill = self.fill
        # Convert the `fill` to appropriate format.
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(img)
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstance(img, Image.Image) == True`
            self.current_fill = fill

        return super(RandomAffine, self).cascade_transform(img=img, params=params)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        img_size = tv_fn.get_image_size(img)
        params = self.get_params(
            self.degrees, self.translate, self.scale, self.shear, img_size=img_size
        )
        return params

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """

        fill: t.List[float] = self.current_fill

        return tv_fn.affine(
            img,
            *params,
            interpolation=self.interpolation,
            fill=fill,
            center=self.center,
        )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (
            params[0],
            params[1][0],
            params[1][1],
            params[2],
            params[3][0],
            params[3][1],
        )

    def consume_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.

        1. To maintain parity with pre-processing of the image data in
        `RandomAffine` transform of `torchvision`, we borrow code from `forward`
        method of `RandomAffine` class.
        """

        fill = self.fill
        # Convert the `fill` to appropriate format.
        if isinstance(img, torch.Tensor):
            if isinstance(fill, (int, float)):
                self.current_fill = [float(fill)] * tv_fn.get_image_num_channels(img)
            else:
                self.current_fill = [float(f) for f in fill]
        else:  # `isinstance(img, Image.Image) == True`
            self.current_fill = fill

        return super(RandomAffine, self).consume_transform(img=img, params=params)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return (params[0], [params[1], params[2]], params[3], [params[4], params[5]])

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (0.0, (0, 0), 1.0, (0.0, 0.0))
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"degrees={self.degrees}, "
            f"translate={self.translate}, "
            f"scale={self.scale}, "
            f"shear={self.shear}, "
            f"interpolation={self.interpolation}, "
            f"fill={self.fill}, "
            f"center={self.center}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class Grayscale(ptc.AtomicTransform, tvtx.Grayscale):
    """Converts the input image to grayscale."""

    def __init__(
        self,
        num_output_channels: int = 1,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param num_output_channels: The number of channels in the output
            gray-scaled image.
            DEFAULT: 1
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(Grayscale, self).__init__(
            num_output_channels=num_output_channels, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 0

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        return ()

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        return tvtx.Grayscale.__call__(self, img)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return (), params

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = ()
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"num_output_channels={self.num_output_channels}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomGrayscale(ptc.AtomicTransform, tvtx.RandomGrayscale):
    """Converts the input image to grayscale at random with given probability."""

    def __init__(
        self,
        p: float = 0.1,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to convert to grayscale.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomGrayscale, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        num_output_channels = tv_fn.get_image_num_channels(img)
        if params[0]:
            return tv_fn.rgb_to_grayscale(
                img=img, num_output_channels=num_output_channels
            )
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomErasing(ptc.AtomicTransform, tvtx.RandomErasing):
    """Removes a randomly selected rectangular region in the image."""

    def __init__(
        self,
        p: float = 0.5,
        scale: t.Union[t.Tuple[float, float], t.List[float]] = (0.02, 0.33),
        ratio: t.Union[t.Tuple[float, float], t.List[float]] = (0.3, 3.3),
        value: t.Union[int, str, t.List[int], t.Tuple[int, int, int]] = 0,
        inplace: bool = False,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
        default_params_mode: ptc.DefaultParamsMode = ptc.DefaultParamsMode.RANDOMIZED,
    ) -> None:
        """
        :param p: The probability with which to apply this transform.
        :param scale: The lower and upper bounds to the proportion of the area
            of the rectangle to remove against the area of the image.
            DEFAULT: `(0.02, 0.33)`.
        :param ratio: The lower and upper bounds to the aspect ratio of the
            rectangle that needs to be removed.
            DEFAULT: `(0.3, 3.3)`.
        :param value: The value that needs to be used to fill up the removed
            rectangle. If `int`, it is used in all channels of the removed
            rectangle to fill. If a list/tuple of length 3, it is used to fill
            the three channels of the image. If the string `random` is used,
            the removed rectangle is substituted with random noise.
            DEFAULT: `0`.
        :param inplace: Whether to perform this transform inplace.
            DEFAULT: `False`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        :param default_params_mode: The mode of the default params.
            SUPPORT: `ptc.DefaultParamsMode.{UNIQUE,RANDOMIZED}`.
            DEFAULT: `ptc.DefaultParamsMode.RANDOMIZED`.

        Notes:
        1. We can consider encoding fill `value` of `random` in
        parameterization in a unified manner as a future plan.
        """

        super(RandomErasing, self).__init__(
            p=p, scale=scale, ratio=ratio, value=value, inplace=inplace, tx_mode=tx_mode
        )

        # Set extra attributes.
        self.default_params_mode = default_params_mode

        # Set the value reference.
        self.value_ref = None
        self._set_value_reference()

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 4

    def _set_value_reference(self) -> None:
        """Sets the value reference for skipping `value` from parameters and
        incorporating modularization.
        """

        if isinstance(self.value, (int, float)):
            self.value_ref = [
                self.value,
            ]
        elif isinstance(self.value, str):
            self.value_ref = None
        elif isinstance(self.value, tuple):
            self.value_ref = list(self.value)
        else:
            self.value_ref = self.value

        self.value_replacement = (
            torch.tensor(self.value_ref)[:, None, None]
            if self.value_ref is not None
            else None
        )

    def cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and previous parameters, generate the parameters
        for the current transform, augment previous parameters with current
        parameters, and return the augmented parameters.

        :param img: The data point to be augmented.
        :param params: The previously collected parameters.

        :returns: The augmented data point and the corresponding parameters
            appended to the previously collected params.
        """

        if self.value_ref is not None and not (
            len(self.value_ref) in (1, img.shape[-3])
        ):
            raise ValueError(
                "If value is a sequence, it should have either a single value or "
                f"{img.shape[-3]} (number of input channels)"
            )

        return super(RandomErasing, self).cascade_transform(img=img, params=params)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            i, j, h, w, v = self.get_params(
                img=img, scale=self.scale, ratio=self.ratio, value=self.value_ref
            )
            return i, j, h, w

        # If apply default and default is randomized, return any default.
        if self.default_params_mode == ptc.DefaultParamsMode.RANDOMIZED:
            H, W = tv_fn.get_image_size(img=img)
            i, j = np.random.randint(low=0, high=H), np.random.randint(low=0, high=W)
            return i, j, 0, 0

        # Else, return a static default.
        return 0, 0, 0, 0

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """

        # Extract core parameters.
        i, j, h, w = params

        # Fetch the final value replacement.
        if self.value_replacement is not None:
            v = self.value_replacement
        else:
            channels = img.shape[-3]
            v = torch.empty([channels, h, w], dtype=torch.float32).normal_()

        return tv_fn.erase(img=img, i=i, j=j, h=h, w=w, v=v)

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def consume_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Input the data point and parameters, extract the required number of
        parameters, performs the required transforms, and returns the
        augmented data point along with remaining parameters.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of augmented data point and remaining parameters.
        """

        if self.value_ref is not None and not (
            len(self.value_ref) in (1, img.shape[-3])
        ):
            raise ValueError(
                "If value is a sequence, it should have either a single value or "
                f"{img.shape[-3]} (number of input channels)"
            )

        return super(RandomErasing, self).consume_transform(img=img, params=params)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """

        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        if self.default_params_mode == ptc.DefaultParamsMode.RANDOMIZED:
            H, W = tv_fn.get_image_size(img=img)
            i, j = np.random.randint(low=0, high=H), np.random.randint(low=0, high=W)
            raw_id_params = (i, j, 0, 0)
        else:
            raw_id_params = (0, 0, 0, 0)

        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"scale={self.scale}, "
            f"ratio={self.ratio}, "
            f"value={self.value}, "
            f"inplace={self.inplace}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class GaussianBlur(ptc.AtomicTransform, tvtx.GaussianBlur):
    """Applies the Gaussian denoising blur to the image."""

    def __init__(
        self,
        kernel_size: t.Union[int, t.List[int], t.Tuple[int, int]],
        sigma: t.Union[float, t.List[float], t.Tuple[float, float]],
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param kernel_size: Size of the Gaussian kernel.
        :param sigma: The standard deviation of the Gaussian distribution to
            be used for the transform.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(GaussianBlur, self).__init__(
            kernel_size=kernel_size, sigma=sigma, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        # Get the `sigma` used for the Gaussian blur.
        sigma = self.get_params(self.sigma[0], self.sigma[1])
        return (sigma,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        sigma = params[0]

        if sigma == 0:
            return img

        return tv_fn.gaussian_blur(
            img=img, kernel_size=self.kernel_size, sigma=[sigma, sigma]
        )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (0.0,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"kernel_size={self.kernel_size}, "
            f"sigma={self.sigma}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomInvert(ptc.AtomicTransform, tvtx.RandomInvert):
    """Inverts the colors of the image by subtracting all pixel values from
    the maximum value of the pixel values. This is equivalent to
    `img <- I - img`, where `I` represents the max value of the pixels based
    on the image datatype.
    """

    def __init__(
        self,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to invert the image.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomInvert, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.invert(img=img)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomPosterize(ptc.AtomicTransform, tvtx.RandomPosterize):
    """Posterize the image by reducing the number of bits per color channel
    at random with a given probability.
    """

    def __init__(
        self,
        bits: int,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param bits: The number of bits to keep per color channel (0-8).
        :param p: The probability of applying the transform.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomPosterize, self).__init__(bits=bits, p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.posterize(img=img, bits=self.bits)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"bits={self.bits}, "
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomSolarize(ptc.AtomicTransform, tvtx.RandomSolarize):
    """Solarizes the image at random with a given probability."""

    def __init__(
        self,
        threshold: float,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param threshold: The threshold for inverting pixels; all the pixels
            with value equal or above this threshold will be inverted.
        :param p: The probability with which to apply this transform.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomSolarize, self).__init__(threshold=threshold, p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.solarize(img=img, threshold=self.threshold)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"threshold={self.threshold}, "
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomAdjustSharpness(ptc.AtomicTransform, tvtx.RandomAdjustSharpness):
    """Adjusts the sharpness at random with given probability."""

    def __init__(
        self,
        sharpness_factor: float,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param sharpness_factor: The amount by which to increase the sharpness
            of the image. To maintain the sharpness as is, use value of `1.`.
        :param p: The probability with which to apply this transform.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomAdjustSharpness, self).__init__(
            sharpness_factor=sharpness_factor, p=p, tx_mode=tx_mode
        )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.adjust_sharpness(
                img=img, sharpness_factor=self.sharpness_factor
            )
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"sharpness_factor={self.sharpness_factor}, "
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomAutocontrast(ptc.AtomicTransform, tvtx.RandomAutocontrast):
    """Autocontrasts the given image at random with given probability."""

    def __init__(
        self,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to apply this transform.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomAutocontrast, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.autocontrast(img=img)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"p={self.p}, "
            f"param_count={self.param_count}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class RandomEqualize(ptc.AtomicTransform, tvtx.RandomEqualize):
    """Equalizes histogram of given image at random with given probability."""

    def __init__(
        self,
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param p: The probability with which to apply this transform.
            DEFAULT: `0.5`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomEqualize, self).__init__(p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        return (False,)

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        if params[0]:
            return tv_fn.equalize(img=img)
        return img

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),)

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        if params[0] <= 0.5:
            return (False,)
        return (True,)

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = (False,)
        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"param_count={self.param_count}, "
            f"p={self.p}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


class ElasticTransform(ptc.AtomicTransform, tvtx.ElasticTransform):
    """Generates a displacement field for all pixels of the image based on
    `alpha` parameter for the strength of displacements and `sigma` for the
    smoothness of displacements, and applies the field to generate elastically
    deformed version of the image."""

    def __init__(
        self,
        image_shape: t.Union[int, t.List[int], t.Tuple[int, int]],
        alpha: t.Union[float, t.List[float], t.Tuple[float, float]] = 50.0,
        sigma: t.Union[float, t.List[float], t.Tuple[float, float]] = 5.0,
        interpolation: tv_fn.InterpolationMode = tv_fn.InterpolationMode.BILINEAR,
        fill: t.Union[float, t.Sequence[float]] = 0.0,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param image_shape: The shape of the images to be processed.
        :param alpha: The parameter to control magnitude of displacements.
            DEFAULT: `50.0`.
        :param sigma: The parameter to control smoothness of displacements.
            DEFAULT: `5.0`.
        :param interpolation: Interpolation to apply for displacing pixels.
            DEFAULT: `tv_fn.InterpolationMode.BILINEAR`.
        :param fill: The value to fill in areas outside the transformed image.
            DEFAULT: `0.`.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.

        Note that since the parametrization is the displacement field itself,
        we need to know the shape of the image apriori in order to define the
        number of parameters in this transform.
        """
        super(ElasticTransform, self).__init__(
            alpha=alpha,
            sigma=sigma,
            interpolation=interpolation,
            fill=fill,
            tx_mode=tx_mode,
        )

        if isinstance(image_shape, int):
            self.image_shape = [image_shape, image_shape]
        elif isinstance(image_shape, (list, tuple)):
            assert len(image_shape) == 2, (
                "ERROR | Input `image_shape` should either be single integer "
                f"or a 2-length sequence of integers; found: {image_shape}"
            )
            self.image_shape = list(image_shape)
        else:
            raise TypeError(
                "ERROR | Input `image_shape` should either be single integer "
                f"or a 2-length sequence of integers; found: {image_shape}"
            )

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.

        Note that since the entire displacement field is in parameterization,
        we need `2 * H * W`-many parameters for an image of size `C x H x W`.
        """
        return 2 * self.image_shape[0] * self.image_shape[1]

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return tvtx.ElasticTransform.get_params(
            alpha=self.alpha, sigma=self.sigma, size=self.image_shape
        )

    def apply_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.IMAGE_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image.
        """
        try:
            return tv_fn.elastic_transform(
                img=img,
                displacement=params,
                interpolation=self.interpolation,
                fill=self.fill,
            )

        except Exception as e:
            raise e.__class__(
                "ERROR | Can not apply given displacement of shape: "
                f"{params.shape} to given image: {img};\n"
                f"ERROR | \tSuggestion: check if the shape "
                "of the image matches the `image_shape` in the initializer; "
                f"hit error:\n{e}"
            )

    def post_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.

        :returns: The post-processed parameters.
        """
        return tuple(params.flatten().cpu().tolist())

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        tensor_params = torch.tensor(data=params).reshape(
            1, self.image_shape[0], self.image_shape[1], 2
        )

        if isinstance(img, torch.Tensor):
            tensor_params = tensor_params.to(img)

        return tensor_params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """
        raw_id_params = torch.zeros(
            size=[1, self.image_shape[0], self.image_shape[1], 2],
            dtype=torch.float32,
        )

        return (
            self.post_process_params(img=img, params=raw_id_params)
            if processed
            else raw_id_params
        )

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """
        return (
            f"{self.name}("
            f"param_count={self.param_count}, "
            f"image_shape={self.image_shape}, "
            f"alpha={self.alpha}, "
            f"sigma={self.sigma}, "
            f"interpolation={self.interpolation}, "
            f"fill={self.fill}, "
            f"tx_mode={self.tx_mode}"
            f")"
        )


# --------------------------------------------------------------------------------
# Composing transforms from `torchvision`.
# --------------------------------------------------------------------------------


class Compose(ptc.ComposingTransform, tvtx.Compose):
    """Inputs a sequence of transforms and applies each of these transforms on
    the given image in order to generate the augmentation.
    """

    def __init__(
        self,
        transforms: t.Iterable[t.Callable],
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param transforms: The list, tuple, or any other iterable object that
            can produce all the component transforms in the correct order.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(Compose, self).__init__(transforms=transforms, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return ptu.get_total_params_count(transforms=self.transforms)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        return ()

    def apply_cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image and corresponding augmentation parameters.
        """

        aug_params = ()
        for transform in self.transforms:
            img, aug_params = transform.cascade_transform(img, aug_params)

        return img, aug_params

    def post_process_params(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.
        :param aug_params: The processed params from the composition of transforms.

        :returns: The post-processed parameters.
        """
        return params, aug_params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        return (), params

    def apply_consume_transform(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Applies the transform with given parameters by consuming them.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.
        :param aug_params: The parameters from composition of transforms.

        :returns: The augmented image with the remaining parameters.
        """

        for transform in self.transforms:
            img, aug_params = transform.consume_transform(img=img, params=aug_params)

        return img, aug_params

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.

        Note that certain transforms can mutate the image properties and so,
        we obtain the default parameters and use them to keep the image
        mutating exactly as it would have mutated if we were carrying out the
        the forward pass. This ensures that all the transforms of this
        composition will see image with appropriate properties to decide their
        own default transforms.
        """

        params = ()

        for transform in self.transforms:
            # Get the parameters needed.
            temp_params = transform.get_default_params(img=img, processed=processed)
            params += temp_params
            # Apply transform to make image compatible for the next transform!
            img, _ = transform(img, temp_params)

        return params

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """

        start_line = f"{self.name}(\n  tx_mode={self.tx_mode}"

        string_components = []
        for transform in self.transforms:
            string_components.append(
                ptu.indent(data=str(transform), indentor="  ", connector="\n")
            )
        core_tx_string = ",\n".join(string_components)

        end_line = f")"

        return ",\n".join([start_line, core_tx_string, end_line])


class RandomApply(ptc.ComposingTransform, tvtx.RandomApply):
    """Randomly applies a sequence of transforms with given probability."""

    def __init__(
        self,
        transforms: t.Iterable[t.Callable],
        p: float = 0.5,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param transforms: The iterable of transforms that returns the
            transforms in the correct order.
        :param p: The probability of applying this composite transform
            together on the input image.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomApply, self).__init__(transforms=transforms, p=p, tx_mode=tx_mode)

        self.param_count = self.set_param_count()

    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return ptu.get_total_params_count(transforms=self.transforms) + 1

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.

        With probability `self.p`, we want to apply transform. Thus, we take
        a uniform sample from [0, 1] and return `True` or `False` based on the
        sample being smaller than or larger than `self.p`.
        """
        if torch.rand(1) < self.p:
            return (True,)
        else:
            return (False,)

    def apply_cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image and corresponding augmentation parameters.
        """

        # If we have to apply the augmentation, do so.
        if params[0]:
            aug_params = ()
            for transform in self.transforms:
                img, aug_params = transform.cascade_transform(
                    img, aug_params
                )  # All transforms will have the correct signature.
            return img, aug_params

        # Else, we just need to augment the no-aug transforms together.
        else:
            aug_params = ()
            for transform in self.transforms:
                current_id_params = transform.get_default_params(
                    img=img, processed=True
                )
                aug_params += current_id_params
                img, curr_rem_params = transform.consume_transform(
                    img=img, params=current_id_params
                )
                assert curr_rem_params == (), (
                    f"ERROR | After pushing default params: "
                    f"{current_id_params} of transform: {transform} "
                    f"through itself, we get remaining params: "
                    f"{curr_rem_params}, which should ideally be empty: `()`."
                )
            return img, aug_params

    def post_process_params(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.
        :param aug_params: The processed params from the composition of transforms.

        :returns: The post-processed parameters.
        """
        return (float(params[0]),), aug_params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """

        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """

        return (True if params[0] > 0.5 else False,), params[1:]

    def apply_consume_transform(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Applies the transform with given parameters by consuming them.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.
        :param aug_params: The parameters from composition of transforms.

        :returns: The augmented image with the remaining parameters.
        """

        # If we have to apply the augmentation, do so.
        for transform in self.transforms:
            img, aug_params = transform.consume_transform(
                img, aug_params
            )  # All transforms will have the correct signature.
        return img, aug_params  # Here, `aug_params` will have become `()`

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        # The local raw parameters are NOT really needed.
        local_raw_id_params = (False,)

        # Get all default parameters stacked for augmentation parameters.
        aug_raw_id_params = ()
        for transform in self.transforms:
            # Get the parameters needed.
            curr_id_params = transform.get_default_params(img=img, processed=processed)
            aug_raw_id_params += curr_id_params
            # Apply transform to make image compatible for the next transform!
            img, _ = transform.consume_transform(img=img, params=curr_id_params)

        if processed:
            local_proc_id_params, aug_proc_id_params = self.post_process_params(
                img=img, params=local_raw_id_params, aug_params=aug_raw_id_params
            )
            proc_id_params = ptc.Transform.concat_params(
                local_proc_id_params, aug_proc_id_params
            )
            return proc_id_params

        raw_id_params = ptc.Transform.concat_params(
            local_raw_id_params, aug_raw_id_params
        )
        return raw_id_params

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """

        start_line = f"{self.name}(\n  p={self.p}\n  tx_mode={self.tx_mode}"

        string_components = []
        for transform in self.transforms:
            string_components.append(
                ptu.indent(data=str(transform), indentor="  ", connector="\n")
            )
        core_tx_string = ",\n".join(string_components)

        end_line = f")"

        return ",\n".join([start_line, core_tx_string, end_line])


class RandomOrder(ptc.ComposingTransform, tvtx.RandomOrder):
    """Applies a sequence of given transforms but in a randomized order."""

    def __init__(
        self,
        transforms: t.Iterable,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
        default_params_mode: ptc.DefaultParamsMode = ptc.DefaultParamsMode.RANDOMIZED,
    ) -> None:
        """
        :param transforms: The transforms to be applied in a randomized order
            to the input image.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        :param default_params_mode: The mode of the default params.
            SUPPORT: `ptc.DefaultParamsMode.{UNIQUE,RANDOMIZED}`.
            DEFAULT: `ptc.DefaultParamsMode.RANDOMIZED`.
        """

        super(RandomOrder, self).__init__(transforms=transforms, tx_mode=tx_mode)

        self.len = len(self.transforms)
        self.range = np.arange(self.len)
        self.default_params_mode = default_params_mode

        self.param_count = self.set_param_count()

        # Define the start and end indices of parameters for each transform.
        self.limit_idxs = [0]
        for transform in self.transforms:
            self.limit_idxs.append(self.limit_idxs[-1] + transform.param_count)

    # noinspection PyAttributeOutsideInit
    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        # New param count is that of the parent plus number of transforms.
        return ptu.get_total_params_count(transforms=self.transforms) + self.len

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """
        return tuple(np.random.permutation(self.range).tolist())

    def apply_cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image and corresponding augmentation parameters.
        """
        in_order_tx_params = [None for _ in range(self.len)]

        for elt in params:
            img, tx_params = self.transforms[elt].cascade_transform(img, ())
            in_order_tx_params[elt] = tx_params

        assert (
            len(ptc.Transform.concat_params(*in_order_tx_params)) == self.limit_idxs[-1]
        )

        # Return the transformed image and updated params padded with order.
        return img, ptc.Transform.concat_params(*in_order_tx_params)

    def post_process_params(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.
        :param aug_params: The processed params from the composition of transforms.

        :returns: The post-processed parameters.
        """
        return params, aug_params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """
        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """
        randomness_params, aug_params = params[: self.len], params[self.len :]
        return randomness_params, aug_params

    def apply_consume_transform(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Applies the transform with given parameters by consuming them.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.
        :param aug_params: The parameters from composition of transforms.

        :returns: The augmented image with the remaining parameters.
        """

        for elt in params:
            transform_aug_params = aug_params[
                self.limit_idxs[elt] : self.limit_idxs[elt + 1]
            ]
            img, rem_aug_params = self.transforms[elt].consume_transform(
                img, transform_aug_params
            )

            assert rem_aug_params == ()

        # Return the transformed image and updated params padded with order.
        return img, ()

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        local_raw_id_params = (
            tuple(self.range)
            if self.default_params_mode == ptc.DefaultParamsMode.UNIQUE
            else tuple(np.random.permutation(self.range))
        )

        aug_raw_id_params = ()

        for transform in self.transforms:
            # Get the parameters needed.
            temp_params = transform.get_default_params(img=img, processed=processed)
            aug_raw_id_params += temp_params
            # Apply transform to make image compatible for the next transform!
            img, _ = transform(img, temp_params)

        if processed:
            local_proc_id_params, aug_proc_id_params = self.post_process_params(
                img=img, params=local_raw_id_params, aug_params=aug_raw_id_params
            )
            proc_id_params = ptc.Transform.concat_params(
                local_proc_id_params, aug_proc_id_params
            )
            return proc_id_params

        raw_id_params = ptc.Transform.concat_params(
            local_raw_id_params, aug_raw_id_params
        )
        return raw_id_params

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """

        start_line = f"{self.name}(\n  tx_mode={self.tx_mode}"

        string_components = []
        for transform in self.transforms:
            string_components.append(
                ptu.indent(data=str(transform), indentor="  ", connector="\n")
            )
        core_tx_string = ",\n".join(string_components)

        end_line = f")"

        return ",\n".join([start_line, core_tx_string, end_line])


class RandomChoice(ptc.ComposingTransform, tvtx.RandomChoice):
    """Apply a single transform randomly from a sequence of given transforms."""

    def __init__(
        self,
        transforms: t.Iterable,
        p: t.Optional[t.Iterable] = None,
        tx_mode: ptc.TRANSFORM_MODE_TYPE = ptc.TransformMode.CASCADE,
    ) -> None:
        """
        :param transforms: An iterable of all transforms that returns the
            transforms in one fixed order; for instance, a list or a tuple.
        :param p: The probabilities to weigh the choice.
        :param tx_mode: The mode of the transform.
            DEFAULT: `ptc.TransformMode.CASCADE`.
        """

        super(RandomChoice, self).__init__(transforms=transforms, tx_mode=tx_mode)

        self.len = len(self.transforms)
        self.weights = self.p

        # Assert that the p and transforms have broadcastable lengths.
        assert (self.weights is None) or (len(self.weights) == len(self.transforms)), (
            f"ERROR | The weights : {self.weights} should either be `None` or "
            "their length must match the number of transforms."
        )

        self.param_count = self.set_param_count()

        # Define the start and end indices of parameters for each transform.
        self.limit_idxs = [0]
        for transform in self.transforms:
            self.limit_idxs.append(self.limit_idxs[-1] + transform.param_count)
        assert self.limit_idxs[-1] == self.param_count

    # noinspection PyAttributeOutsideInit
    def set_param_count(self) -> int:
        """Returns the total number of processed parameters generated by the
        transform under consideration.

        :returns: The number of parameters for this transform.
        """

        return ptu.get_total_params_count(transforms=self.transforms)

    def get_raw_params(self, img: ptc.IMAGE_TYPE) -> ptc.PARAM_TYPE:
        """Generates the raw parameters used to augment current data point.

        :param img: The data point to be augmented.

        :returns: Current raw parameters to augment the data point.
        """

        # Choose the index and the transform to apply.
        return (np.random.choice(self.len, p=self.weights),)

    def apply_cascade_transform(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE, **kwargs
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Augments given data point using given parameters.

        :param img: The data point to be augmented.
        :param params: The parameters to be used for augmentation.

        :returns: The augmented image and corresponding augmentation parameters.
        """

        tx_idx = params[0]
        aug_img, tx_aug_params = self.transforms[tx_idx].cascade_transform(
            img=img, params=()
        )

        aug_params_list = []
        for core_tx_idx, core_tx in enumerate(self.transforms):
            if core_tx_idx == tx_idx:
                aug_params_list.append(tx_aug_params)
            else:
                aug_params_list.append(
                    core_tx.get_default_params(img=img, processed=True)
                )

        aug_params = ptc.Transform.concat_params(*aug_params_list)

        return aug_img, aug_params

    def post_process_params(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Post-processes the parameters of augmentations before outputting.

        :param img: The data point to be augmented.
        :param params: The raw local parameters to be post-processed.
        :param aug_params: The processed params from the composition of transforms.

        :returns: The post-processed parameters.
        """
        return (), aug_params

    def extract_params(
        self, params: ptc.PARAM_TYPE
    ) -> t.Tuple[ptc.PARAM_TYPE, ptc.PARAM_TYPE]:
        """Chunks the input parameters into two sets; the first required for
        the augmentation of the current data and the second to pass on to the
        next augmentations.

        :param params: The parameters remaining from the augmentations so far.

        :returns: The tuple of the local and subsequent parameters.
        """

        return params[: self.param_count], params[self.param_count :]

    def pre_process_params(
        self, img: ptc.IMAGE_TYPE, params: ptc.PARAM_TYPE
    ) -> ptc.PARAM_TYPE:
        """Pre-processes the parameters of augmentations after inputting.

        :param img: The data point to be augmented.
        :param params: The parameters from which to extract local parameters.

        :returns: The pre-processed parameters ready for their usage.
        """

        return (), params

    def apply_consume_transform(
        self,
        img: ptc.IMAGE_TYPE,
        params: ptc.PARAM_TYPE,
        aug_params: ptc.PARAM_TYPE,
    ) -> ptc.TRANSFORM_RETURN_TYPE:
        """Applies the transform with given parameters by consuming them.

        :param img: The data point to be augmented.
        :param params: The parameters remaining from the augmentations so far.
        :param aug_params: The parameters from composition of transforms.

        :returns: The augmented image with the remaining parameters.
        """

        for core_tx_idx, core_tx in enumerate(self.transforms):
            curr_tx_params = aug_params[
                self.limit_idxs[core_tx_idx] : self.limit_idxs[core_tx_idx + 1]
            ]
            img, rem_curr_tx_params = core_tx.consume_transform(
                img=img, params=curr_tx_params
            )
            assert rem_curr_tx_params == (), (
                f"ERROR | Core transform: {core_tx} failed to consume "
                f"all its parameters {curr_tx_params}."
            )

        return img, ()

    def get_default_params(
        self, img: ptc.IMAGE_TYPE, processed: bool = True
    ) -> ptc.PARAM_TYPE:
        """Returns the parameters for preserving the input data information.

        :param img: The data point to be augmented.
        :param processed: Whether we want the processed default parameters.

        :returns: The no-augmentation params for the class.
        """

        id_params_list = []
        for core_tx in self.transforms:
            id_params_list.append(
                core_tx.get_default_params(img=img, processed=processed)
            )
        return ptc.Transform.concat_params(*id_params_list)

    def __str__(self) -> str:
        """Defines the string representation of the transform.

        :returns: The string representation of the transform.
        """

        start_line = f"{self.name}(\n  p={self.weights}\n  tx_mode={self.tx_mode}"

        string_components = []
        for transform in self.transforms:
            string_components.append(
                ptu.indent(data=str(transform), indentor="  ", connector="\n")
            )
        core_tx_string = ",\n".join(string_components)

        end_line = f")"

        return ",\n".join([start_line, core_tx_string, end_line])
